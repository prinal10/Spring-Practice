<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN" "http://www.springframework.org/dtd/spring-beans-2.0.dtd">

<!--
 default-destroy-method="methodName() default-init-method="myInit" :
 similar to the the init and destroy method used below in the bean tag but this is at global level and so this will
 be the default init and destroy for all beans.
 -->
<beans default-destroy-method="beforeDestroy" default-init-method="myInit">
		<!-- 
		If the abstract para is set to true then the spring container will not initialize that bean
		and so we can use such bean as template/parent bean from which we can inherit common properties.
		 -->
		<bean id="parent-triangle" class="com.demo.model.Triangle" abstract="true">
			<property name="pointE">
				<bean class="com.demo.model.Point">
					<property name="x" value="0"></property>
					<property name="y" value="0"></property>
				</bean>
			</property>
			<property name="points">
 				<list>
 					<ref bean="zeroPoint"/>
 				</list>
 			</property>
		</bean>

		<!--BEAN PARA
		scope="singleton/prototype". Spring container will create bean object while reading the xml file and will pass
		the same object to any call from class or ref made in the xml itself. But when it is prototype the bean object is 
		created every time a ref or request is made to the bean in the xml.
		
		parent="parentBeanId". Use to inherit the properties from another bean. See the list property, we can set the "merge"
		para true and add more elements to the list property in the parent bean. 
		
		init-method="methodName()". Use to register a initialization method (destroy method like that in JSP) which is called 
		before the bean has been destroyed at the end of the program.
		
		destroy-method="methodName()". Use to register a destroy method (init method like that in JSP) which is called 
		after the bean properties has been initialized in the xml.
			 
		 -->
	<bean id="triangle" class="com.demo.model.Triangle" scope="singleton" name="triangle-name" autowire="byName" parent="parent-triangle" init-method="myInit"
	destroy-method="beforeDestroy">
		
		<!-- 
			<property name="type" value="Equilateral"></property>
		 -->
		<!--
		Property tag is used to set the class member variables using the setter and getter,
		but instead of using this if we want to use the constructor than we will
		use the following tag called "constructor". If there is a constructor with 2 para then
		we will use another same tag for constructor with 2 para. The tag takes string as para value.
		So we have 2 constructors taking "int" & "string" as para then we can specify here by using "type"
 		Similarly we can use "index" para in tag to specify the index of the para in the constructor
 		-->
 		<!-- <constructor-arg index="0" value="Colleteral"></constructor-arg>
 		<constructor-arg index="1" type ="int" value="20"></constructor-arg> -->
 		
 		
 		<!-- 
 		In the below tag the "ref" para tells the spring bean to assign a new Point object to pointA variable using the 
 		reference zeroPoint which is nothing but a bean that creates a new Point object same as "new Point()". 
 		It checks whether both have the same data type and then sets the value of the variable
 		 -->
 		<property name="pointA" ref="zeroPoint"></property>
 		
 		<!-- 
 		As you can see if the bean is to be used by one class only then we can limit the scope
 		by not referencing bean and instead put it in the property tag itself. Compare "pointA" 
 		with "pointB & pointC". pointA will be used by all but B & C will be use by triangle only.
 		Also since we can not use or refer pointB &C bean outside property tag we can
 		remove the bean "id" para	
 		 -->
 		<property name="pointB">
 			<bean class="com.demo.model.Point">
				<property name="x" value="-20"></property>
				<property name="y" value="0"></property>
			</bean>
 		</property>
 		
 		<property name="pointC">
 			<bean class="com.demo.model.Point">
				<property name="x" value="20"></property>
				<property name="y" value="0"></property>
			</bean>	
 		</property>
 		
 		<!--
 		Suppose we have a Collection Framework Object variable: for example here we have
 		List Object variable "points". So to insert values we will use the "list" tag and 
 		repeat the "ref" tag to add objects/values in the list. Type conversion also happens 
 		here. Merge is used to add more element to list inherited from a parent bean. 		 
 		 -->
 		<property name="points">
 			<list merge="true">
 				<ref bean="zeroPoint"/>
 				<ref bean="zeroPoint"/>
 				<ref bean="zeroPoint"/> 				
 			</list>
 		</property>
 		
 		
 		
	</bean>
	
	<bean id="zeroPoint" class="com.demo.model.Point">
		<property name="x" value="0"></property>
		<property name="y" value="1"></property>
	</bean>
	
	<!--
	"Autowiring" is enabled by using the "autowire = byName" tag in the triangle bean.
	After that create a bean with the same name as the triangle member variable name,
	here it is "pointD". We don't have to write  <property name="pointD" ref="pointD"></property>
	or specify any property with reference. Instead everything is initialize automatically. So
	triangle bean will look for a bean with the same id/name/alia-name as its member variable and
	initialize the member variable with the found bean
	 -->
	<bean id="pointD" class="com.demo.model.Point">
		<property name="x" value="40"></property>
		<property name="y" value="0"></property>
	</bean>
	
	
	<!--
		"alias" is used to give another name to the bean for referencing. we can also
		use "name" para in the bean itself to give another name. We can write multiple 
		aliases for a bean. We can use these alias in the main method to get the bean
	 -->   
	<alias name="triangle" alias="triangle-alias1"/>
	<alias name="triangle" alias="triangle-alias2"/>
	
	
	
	
	
</beans>